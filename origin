/*/*/*
 * Copyright (c) 2017, Michel Martens <mail at soveran dot com> * Copyright (c) 2017, Michel Martens <mail at soveran dot com> * Copyright (c) 2017, Michel Martens <mail at soveran dot com>
 * * *
 * All rights reserved. * All rights reserved. * All rights reserved.
 * * *
 * Redistribution and use in source and binary forms, with or without * Redistribution and use in source and binary forms, with or without * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are * modification, are permitted provided that the following conditions are * modification, are permitted provided that the following conditions are
 * met: * met: * met:
 * * *
 *  *  Redistributions of source code must retain the above copyright *  *  Redistributions of source code must retain the above copyright *  *  Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer. *     notice, this list of conditions and the following disclaimer. *     notice, this list of conditions and the following disclaimer.
 * * *
 *  *  Redistributions in binary form must reproduce the above copyright *  *  Redistributions in binary form must reproduce the above copyright *  *  Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the *     notice, this list of conditions and the following disclaimer in the *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution. *     documentation and/or other materials provided with the distribution. *     documentation and/or other materials provided with the distribution.
 * * *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * * *
 */ */ */

#include <stdio.h>#include <stdio.h>#include <stdio.h>
#include <stdlib.h>#include <stdlib.h>#include <stdlib.h>
#include <string.h>#include <string.h>#include <string.h>
#include <ctype.h>#include <ctype.h>#include <ctype.h>
#include <errno.h>#include <errno.h>#include <errno.h>
#include <math.h>#include <math.h>#include <math.h>
#include "linenoise.h"#include "linenoise.h"#include "linenoise.h"
#include "sds.h"#include "sds.h"#include "sds.h"

/* UI */  /* UI */  /* UI */  
#define HINT_COLOR 33#define HINT_COLOR 33#define HINT_COLOR 33
#define OUTPUT_FMT "\x1b[33m= %g\x1b[0m\n"#define OUTPUT_FMT "\x1b[33m= %g\x1b[0m\n"#define OUTPUT_FMT "\x1b[33m= %d\x1b[0m\n"
#define WORDEF_FMT "%s \x1b[33m\"%s\"\x1b[0m\n"#define WORDEF_FMT "%s \x1b[33m\"%s\"\x1b[0m\n"#define WORDEF_FMT "%s \x1b[33m\"%s\"\x1b[0m\n"

/* Config */  /* Config */  /* Config */  
#define BUFFER_MAX 1024#define BUFFER_MAX 1024#define BUFFER_MAX 1024
#define WORDS_FILE "clac/words"#define WORDS_FILE "clac/words"#define WORDS_FILE "clac/words"
#define CAPACITY   0xFF#define CAPACITY   0xFF#define CAPACITY   0xFF

/* Stack *//* Stack *//* Stack */
#define count(S)   ((S)->top)#define count(S)   ((S)->top)#define count(S)   ((S)->top)
#define clear(S)   ((S)->top = 0)#define clear(S)   ((S)->top = 0)#define clear(S)   ((S)->top = 0)
#define isfull(S)  ((S)->top == CAPACITY)#define isfull(S)  ((S)->top == CAPACITY)#define isfull(S)  ((S)->top == CAPACITY)
#define isempty(S) ((S)->top == 0)#define isempty(S) ((S)->top == 0)#define isempty(S) ((S)->top == 0)

/* Arithmetic *//* Arithmetic *//* Arithmetic */
#define modulo(A, B) (A - B * floor(A / B))#define modulo(A, B) (A - B * floor(A / B))#define modulo(A, B) (A - B * floor(A / B))

typedef struct stack {typedef struct stack {typedef struct stack {
	double items[CAPACITY];	double items[CAPACITY];	int top;
	int top;	int top;	int items[CAPACITY];
} stack;} stack;} stack;

typedef struct node {typedef struct node {typedef struct node {
	sds word;	sds word;	sds word;
	sds meaning;	sds meaning;	sds meaning;
	struct node *next;	struct node *next;	struct node *next;
} node;} node;} node;

static stack stacks[] = {{{}, 0}, {{}, 0}};static stack stacks[] = {{{}, 0}, {{}, 0}};typedef struct hcamp_context {
static stack *s0 = &stacks[0];static stack *s0 = &stacks[0];	stack stacks[2];
static stack *s1 = &stacks[1];static stack *s1 = &stacks[1];	stack *s0;
static node *head = NULL;static node *head = NULL;	stack *s1;
static sds result;static sds result;	node *head;
static double hole = 0;static double hole = 0;	sds result;
	int hole;
static int isoverflow(stack *s) {static int isoverflow(stack *s) {} hcamp_context;
	if (isfull(s)) {	if (isfull(s)) {
		fprintf(stderr, "\r\nStack is full!\n");		fprintf(stderr, "\r\nStack is full!\n");typedef hcamp_context* p_context;
		return 1;		return 1;
	}	}p_context mc;

	return 0;	return 0;static void init_hcamp_context(p_context context) {
}}	context->s0 = &context->stacks[0];
	context->s1 = &context->stacks[1];
static double peek(stack *s) {static double peek(stack *s) {	context->result = sdsempty();
	if (isempty(s)) {	if (isempty(s)) {	context->head = NULL;
		return 0;		return 0;	context->hole = 0;
	}	}}

	return s->items[s->top-1];	return s->items[s->top-1];static int isoverflow(stack *s) {
}}	if (isfull(s)) {
		fprintf(stderr, "\r\nStack is full!\n");
static void push(stack *s, double value) {static void push(stack *s, double value) {		return 1;
	if (!isoverflow(s)) {	if (!isoverflow(s)) {	}
		s->items[s->top++] = value;		s->items[s->top++] = value;
	}	}	return 0;
}}}

static double pop(stack *s) {static double pop(stack *s) {static int count_s0() {
	if (isempty(s)) {	if (isempty(s)) {	return count(mc->s0);
		return 0;		return 0;}
	}	}
static int count_s1() {
	return s->items[--s->top];	return s->items[--s->top];	return count(mc->s1);
}}}

static void move(stack *s, stack *t, int n) {static void move(stack *s, stack *t, int n) {static void clear_s0() {
	while (!isempty(s) && n > 0) {	while (!isempty(s) && n > 0) {	clear(mc->s0);
		push(t, pop(s));		push(t, pop(s));}
		n--;		n--;
	}	}static void clear_s1() {
}}	clear(mc->s1);
}
static void roll(stack *s, stack *aux, int m, int n) {static void roll(stack *s, stack *aux, int m, int n) {
	if (m > count(s)) {	if (m > count(s)) {static int isfull_s0() {
		m = count(s);		m = count(s);	return isfull(mc->s0);
	}	}}

	if (m < 2) {	if (m < 2) {static int isfull_s1() {
		return;		return;	return isfull(mc->s1);
	}	}}

	if (n < 0) {	if (n < 0) {static int isempty_s0() {
		n = m - modulo(abs(n), m);		n = m - modulo(abs(n), m);	return isempty(mc->s0);
	}	}}

	if (n == 0 || n == m) {	if (n == 0 || n == m) {static int isempty_s1() {
		return;		return;	return isempty(mc->s1);
	}	}}

	m--;	m--;static int __peek(stack *s) {
	return s->items[s->top-1];
	double a;	double a;}

	while (n > 0) {	while (n > 0) {static int peek_s0() {
		a = pop(s);		a = pop(s);	if (isempty(mc->s0)) {
		move(s, aux, m);		move(s, aux, m);		return 0;
		push(s, a);		push(s, a);	}
		move(aux, s, m);		move(aux, s, m);	return __peek(mc->s0);
		n--;		n--;}
	}	}
}}static int peek_s1() {
	if (isempty(mc->s1)) {
static double add(stack *s, int n) {static double add(stack *s, int n) {		return 0;
	double a = pop(s);	double a = pop(s);	}
	return __peek(mc->s1);
	while (!isempty(s) && n > 1) {	while (!isempty(s) && n > 1) {}
		a += pop(s);		a += pop(s);
		n--;		n--;static void __push(stack *s, int value) {
	}	}	s->items[s->top++] = value;
}
	return a;	return a;
}}static void push_s0(int value) {
	if (isoverflow(mc->s0)) {
static node *get(sds word) {static node *get(sds word) {		return;
	node *curr = head;	node *curr = head;	}
	return __push(mc->s0, value);
	while (curr != NULL) {	while (curr != NULL) {}
		if (!strcasecmp(word, curr->word)) {		if (!strcasecmp(word, curr->word)) {
			return curr;			return curr;static void push_s1(int value) {
		}		}	if (isoverflow(mc->s1)) {
		return;
		curr = curr->next;		curr = curr->next;	}
	}	}	return __push(mc->s1, value);
}
	return NULL;	return NULL;
}}static int __pop(stack *s) {
	return s->items[--s->top];
static void set(sds word, sds meaning) {static void set(sds word, sds meaning) {}
	node *curr = get(word);	node *curr = get(word);
static int pop_s0() {
	if (curr != NULL) {	if (curr != NULL) {	if (isempty(mc->s0)) {
		fprintf(stderr, "Duplicate definition of \"%s\"\n", word);		fprintf(stderr, "Duplicate definition of \"%s\"\n", word);		return 0;
		curr->meaning = meaning;		curr->meaning = meaning;	}
		return;		return;	return __pop(mc->s0);
	}	}}

	curr = (node *) malloc(sizeof(node));	curr = (node *) malloc(sizeof(node));static int pop_s1() {
	if (isempty(mc->s1)) {
	if (curr == NULL) {	if (curr == NULL) {		return 0;
		fprintf(stderr, "Not enough memory to load words\n");		fprintf(stderr, "Not enough memory to load words\n");	}
		exit(1);		exit(1);	return __pop(mc->s1);
	}	}}

	curr->word = word;	curr->word = word;static void swap(stack *s) {
	curr->meaning = meaning;	curr->meaning = meaning;	int a = __pop(s);
	curr->next = head;	curr->next = head;	int b = __pop(s);
	head = curr;	head = curr;
}}	__push(s, a);
	__push(s, b);
static void cleanup() {static void cleanup() {}
	node *curr;	node *curr;
static void move(stack *s, stack *t, int n) {
	while (head != NULL) {	while (head != NULL) {	while (!isempty(s) && n > 0) {
		curr = head;		curr = head;		__push(t, __pop(s));
		head = curr->next;		head = curr->next;		n--;
	}
		sdsfree(curr->word);		sdsfree(curr->word);}
		sdsfree(curr->meaning);		sdsfree(curr->meaning);
static void roll(stack *s, stack *aux, int m, int n) {
		free(curr);		free(curr);	if (m > count(s)) {
	}	}		m = count(s);
}}	}

static int parse(sds input) {static int parse(sds input) {	if (m < 2) {
	int argc;	int argc;		return;
	sds *argv = sdssplitargs(input, &argc);	sds *argv = sdssplitargs(input, &argc);	}

	if (argc == 0) {	if (argc == 0) {	if (n < 0) {
		sdsfreesplitres(argv, argc);		sdsfreesplitres(argv, argc);		n = m - modulo(abs(n), m);
		return 0;		return 0;	}
	}	}
	if (n == 0 || n == m) {
	if (argc != 2) {	if (argc != 2) {		return;
		sdsfreesplitres(argv, argc);		sdsfreesplitres(argv, argc);	}
		fprintf(stderr, "Incorrect definition: %s\n", input);		fprintf(stderr, "Incorrect definition: %s\n", input);
		return 1;		return 1;	m--;
	}	}
	int a;
	set(argv[0], argv[1]);	set(argv[0], argv[1]);
	while (n > 0) {
	return 0;	return 0;		a = __pop(s);
}}		move(s, aux, m);
		__push(s, a);
static void load(sds filename) {static void load(sds filename) {		move(aux, s, m);
	FILE *fp;	FILE *fp;		n--;
	}
	if ((fp = fopen(filename, "r")) == NULL) {	if ((fp = fopen(filename, "r")) == NULL) {}
		if (errno == ENOENT) {		if (errno == ENOENT) {
			return;			return;static int __add(stack *s, int n) {
		}		}	int a = __pop(s);

		fprintf(stderr, "Can't open file %s\n", filename);		fprintf(stderr, "Can't open file %s\n", filename);	while (!isempty(s) && n > 1) {
		sdsfree(filename);		sdsfree(filename);		a += __pop(s);
		exit(1);		exit(1);		n--;
	}	}	}

	char buf[BUFFER_MAX+1];	char buf[BUFFER_MAX+1];	return a;
	int linecount, i;	int linecount, i;}

	sds *lines;	sds *lines;static int add_s0(int n) {
	sds content = sdsempty();	sds content = sdsempty();	return __add(mc->s0, n);
}
	while(fgets(buf, BUFFER_MAX+1, fp) != NULL) {	while(fgets(buf, BUFFER_MAX+1, fp) != NULL) {
		content = sdscat(content, buf);		content = sdscat(content, buf);static int add_s1(int n) {
	}	}	return __add(mc->s1, n);
}
	fclose(fp);	fclose(fp);
static node *get(p_context pc, sds word) {
	lines = sdssplitlen(content, strlen(content), "\n", 1, &linecount);	lines = sdssplitlen(content, strlen(content), "\n", 1, &linecount);	node *curr = pc->head;

	for (i = 0; i < linecount; i++) {	for (i = 0; i < linecount; i++) {	while (curr != NULL) {
		lines[i] = sdstrim(lines[i], " \t\r\n");		lines[i] = sdstrim(lines[i], " \t\r\n");		if (!strcasecmp(word, curr->word)) {
			return curr;
		if (parse(lines[i]) != 0) {		if (parse(lines[i]) != 0) {		}
			sdsfreesplitres(lines, linecount);			sdsfreesplitres(lines, linecount);
		curr = curr->next;
			fprintf(stderr, "(%s:%d)\n", filename, i+1);			fprintf(stderr, "(%s:%d)\n", filename, i+1);	}
			exit(1);			exit(1);
		}		}	return NULL;
	}	}}

	sdsfreesplitres(lines, linecount);	sdsfreesplitres(lines, linecount);static void set(p_context pc, sds word, sds meaning) {
	sdsfree(content);	sdsfree(content);	node *curr = get(pc, word);
}}
	if (curr != NULL) {
static void eval(const char *input);static void eval(const char *input);		fprintf(stderr, "Duplicate definition of \"%s\"\n", word);
		curr->meaning = meaning;
static void process(sds word) {static void process(sds word) {		return;
	double a, b;	double a, b;	}
	char *z;	char *z;
	node *n;	node *n;	curr = (node *) malloc(sizeof(node));

	if (!strcmp(word, "_")) {	if (!strcmp(word, "_")) {	if (curr == NULL) {
		push(s0, hole);		push(s0, hole);		fprintf(stderr, "Not enough memory to load words\n");
	} else if (!strcmp(word, "+")) {	} else if (!strcmp(word, "+")) {		exit(1);
		if (count(s0) > 1) {		if (count(s0) > 1) {	}
			a = pop(s0);			a = pop(s0);
			b = pop(s0);			b = pop(s0);	curr->word = word;
			push(s0, a + b);			push(s0, a + b);	curr->meaning = meaning;
		}		}	curr->next = pc->head;
	} else if (!strcmp(word, "-")) {	} else if (!strcmp(word, "-")) {	pc->head = curr;
		if (count(s0) > 1) {		if (count(s0) > 1) {}
			a = pop(s0);			a = pop(s0);
			b = pop(s0);			b = pop(s0);static void cleanup(p_context pc) {
			push(s0, b - a);			push(s0, b - a);	node *curr;
		}		}
	} else if (!strcmp(word, "*")) {	} else if (!strcmp(word, "*")) {	while (pc->head != NULL) {
		if (count(s0) > 1) {		if (count(s0) > 1) {		curr = pc->head;
			a = pop(s0);			a = pop(s0);		pc->head = curr->next;
			b = pop(s0);			b = pop(s0);
			push(s0, b * a);			push(s0, b * a);		sdsfree(curr->word);
		}		}		sdsfree(curr->meaning);
	} else if (!strcmp(word, "/")) {	} else if (!strcmp(word, "/")) {
		if (count(s0) > 1) {		if (count(s0) > 1) {		free(curr);
			a = pop(s0);			a = pop(s0);	}
			b = pop(s0);			b = pop(s0);}
			push(s0, b / a);			push(s0, b / a);
		}		}static int parse(p_context pc, sds input) {
	} else if (!strcmp(word, "%")) {	} else if (!strcmp(word, "%")) {	int argc;
		if (count(s0) > 1) {		if (count(s0) > 1) {	sds *argv = sdssplitargs(input, &argc);
			a = pop(s0);			a = pop(s0);
			b = pop(s0);			b = pop(s0);	if (argc == 0) {
			push(s0, modulo(b, a));			push(s0, modulo(b, a));		sdsfreesplitres(argv, argc);
		}		}		return 0;
	} else if (!strcmp(word, "^")) {	} else if (!strcmp(word, "^")) {	}
		if (count(s0) > 1) {		if (count(s0) > 1) {
			a = pop(s0);			a = pop(s0);	if (argc != 2) {
			b = pop(s0);			b = pop(s0);		sdsfreesplitres(argv, argc);
			push(s0, pow(b, a));			push(s0, pow(b, a));		fprintf(stderr, "Incorrect definition: %s\n", input);
		}		}		return 1;
	} else if (!strcasecmp(word, "sum")) {	} else if (!strcasecmp(word, "sum")) {	}
		push(s0, add(s0, count(s0)));		push(s0, add(s0, count(s0)));
	} else if (!strcasecmp(word, "add")) {	} else if (!strcasecmp(word, "add")) {	set(pc, argv[0], argv[1]);
		push(s0, add(s0, pop(s0)));		push(s0, add(s0, pop(s0)));
	} else if (!strcasecmp(word, "abs")) {	} else if (!strcasecmp(word, "abs")) {	return 0;
		if (count(s0) > 0) {		if (count(s0) > 0) {}
			push(s0, fabs(pop(s0)));			push(s0, fabs(pop(s0)));
		}		}static void load(p_context pc, sds filename) {
	} else if (!strcasecmp(word, "ceil")) {	} else if (!strcasecmp(word, "ceil")) {	FILE *fp;
		if (count(s0) > 0) {		if (count(s0) > 0) {
			push(s0, ceil(pop(s0)));			push(s0, ceil(pop(s0)));	if ((fp = fopen(filename, "r")) == NULL) {
		}		}		if (errno == ENOENT) {
	} else if (!strcasecmp(word, "floor")) {	} else if (!strcasecmp(word, "floor")) {			return;
		if (count(s0) > 0) {		if (count(s0) > 0) {		}
			push(s0, floor(pop(s0)));			push(s0, floor(pop(s0)));
		}		}		fprintf(stderr, "Can't open file %s\n", filename);
	} else if (!strcasecmp(word, "round")) {	} else if (!strcasecmp(word, "round")) {		sdsfree(filename);
		if (count(s0) > 0) {		if (count(s0) > 0) {		exit(1);
			push(s0, round(pop(s0)));			push(s0, round(pop(s0)));	}
		}		}
	} else if (!strcasecmp(word, "sin")) {	} else if (!strcasecmp(word, "sin")) {	char buf[BUFFER_MAX+1];
		if (count(s0) > 0) {		if (count(s0) > 0) {	int linecount, i;
			push(s0, sin(pop(s0)));			push(s0, sin(pop(s0)));
		}		}	sds *lines;
	} else if (!strcasecmp(word, "cos")) {	} else if (!strcasecmp(word, "cos")) {	sds content = sdsempty();
		if (count(s0) > 0) {		if (count(s0) > 0) {
			push(s0, cos(pop(s0)));			push(s0, cos(pop(s0)));	while(fgets(buf, BUFFER_MAX+1, fp) != NULL) {
		}		}		content = sdscat(content, buf);
	} else if (!strcasecmp(word, "tan")) {	} else if (!strcasecmp(word, "tan")) {	}
		if (count(s0) > 0) {		if (count(s0) > 0) {
			push(s0, tan(pop(s0)));			push(s0, tan(pop(s0)));	fclose(fp);
		}		}
	} else if (!strcasecmp(word, "ln")) {	} else if (!strcasecmp(word, "ln")) {	lines = sdssplitlen(content, strlen(content), "\n", 1, &linecount);
		if (count(s0) > 0) {		if (count(s0) > 0) {
			push(s0, log(pop(s0)));			push(s0, log(pop(s0)));	for (i = 0; i < linecount; i++) {
		}		}		lines[i] = sdstrim(lines[i], " \t\r\n");
	} else if (!strcasecmp(word, "log")) {	} else if (!strcasecmp(word, "log")) {
		if (count(s0) > 0) {		if (count(s0) > 0) {		if (parse(pc, lines[i]) != 0) {
			push(s0, log10(pop(s0)));			push(s0, log10(pop(s0)));			sdsfreesplitres(lines, linecount);
		}		}
	} else if (!strcasecmp(word, "!")) {	} else if (!strcasecmp(word, "!")) {			fprintf(stderr, "(%s:%d)\n", filename, i+1);
		if (count(s0) > 0) {		if (count(s0) > 0) {			exit(1);
			a = pop(s0);			a = pop(s0);		}
	}
			push(s0, a * tgamma(a));			push(s0, a * tgamma(a));
		}		}	sdsfreesplitres(lines, linecount);
	} else if (!strcasecmp(word, "dup")) {	} else if (!strcasecmp(word, "dup")) {	sdsfree(content);
		if (!isempty(s0)) {		if (!isempty(s0)) {}
			push(s0, peek(s0));			push(s0, peek(s0));
		}		}static void eval(p_context pc, const char *input);
	} else if (!strcasecmp(word, "roll")) {	} else if (!strcasecmp(word, "roll")) {
		a = pop(s0);		a = pop(s0);static void process(p_context pc, sds word) {
		b = pop(s0);		b = pop(s0);	int a, b;
	char *z;
		roll(s0, s1, b, a);		roll(s0, s1, b, a);	node *n;
	} else if (!strcasecmp(word, "swap")) {	} else if (!strcasecmp(word, "swap")) {
		if (count(s0) > 1) {		if (count(s0) > 1) {	if (!strcmp(word, "_")) {
			a = pop(s0);			a = pop(s0);		push_s0(pc->hole);
			b = pop(s0);			b = pop(s0);	} else if (!strcmp(word, "+")) {
		if (count_s0() > 1) {
			push(s0, a);			push(s0, a);			a = pop_s0();
			push(s0, b);			push(s0, b);			b = pop_s0();
		}		}			push_s0(a + b);
	} else if (!strcasecmp(word, "drop")) {	} else if (!strcasecmp(word, "drop")) {		}
		pop(s0);		pop(s0);	} else if (!strcmp(word, "-")) {
	} else if (!strcasecmp(word, "count")) {	} else if (!strcasecmp(word, "count")) {		if (count_s0() > 1) {
		push(s0, (double) count(s0));		push(s0, (double) count(s0));			a = pop_s0();
	} else if (!strcasecmp(word, "clear")) {	} else if (!strcasecmp(word, "clear")) {			b = pop_s0();
		clear(s0);		clear(s0);			push_s0(b - a);
	} else if (!strcasecmp(word, "stash")) {	} else if (!strcasecmp(word, "stash")) {		}
		move(s0, s1, pop(s0));		move(s0, s1, pop(s0));	} else if (!strcmp(word, "*")) {
	} else if (!strcasecmp(word, "fetch")) {	} else if (!strcasecmp(word, "fetch")) {		if (count_s0() > 1) {
		move(s1, s0, pop(s0));		move(s1, s0, pop(s0));			a = pop_s0();
	} else if (!strcasecmp(word, ".")) {	} else if (!strcasecmp(word, ".")) {			b = pop_s0();
		move(s0, s1, 1);		move(s0, s1, 1);			push_s0(b * a);
	} else if (!strcasecmp(word, ",")) {	} else if (!strcasecmp(word, ",")) {		}
		move(s1, s0, 1);		move(s1, s0, 1);	} else if (!strcmp(word, "/")) {
	} else if (!strcasecmp(word, ":")) {	} else if (!strcasecmp(word, ":")) {		if (count_s0() > 1) {
		move(s0, s1, count(s0));		move(s0, s1, count(s0));			a = pop_s0();
	} else if (!strcasecmp(word, ";")) {	} else if (!strcasecmp(word, ";")) {			b = pop_s0();
		move(s1, s0, count(s1));		move(s1, s0, count(s1));			push_s0(b / a);
 	} else if ((n = get(word)) != NULL) { 	} else if ((n = get(word)) != NULL) {		}
 		eval(n->meaning); 		eval(n->meaning);	} else if (!strcmp(word, "%")) {
	} else {	} else {		if (count_s0() > 1) {
		a = strtod(word, &z);		a = strtod(word, &z);			a = pop_s0();
			b = pop_s0();
		if (*z == '\0') {		if (*z == '\0') {			push_s0(modulo(b, a));
			push(s0, a);			push(s0, a);		}
		} else if (!isalpha(word[0])) {		} else if (!isalpha(word[0])) {	} else if (!strcmp(word, "^")) {
			push(s0, NAN);			push(s0, NAN);		if (count_s0() > 1) {
		}		}			a = pop_s0();
	}	}			b = pop_s0();
}}			push_s0(pow(b, a));
		}
static void eval(const char *input) {static void eval(const char *input) {	} else if (!strcasecmp(word, "sum")) {
	int i, argc;	int i, argc;		push_s0(add_s0(count_s0()));
	} else if (!strcasecmp(word, "add")) {
	sds *argv = sdssplitargs(input, &argc);	sds *argv = sdssplitargs(input, &argc);		push_s0(add_s0(pop_s0()));
	} else if (!strcasecmp(word, "abs")) {
	for (i = 0; i < argc; i++) {	for (i = 0; i < argc; i++) {		if (count_s0() > 0) {
		process(argv[i]);		process(argv[i]);			push_s0(fabs(pop_s0()));
	}	}		}
	} else if (!strcasecmp(word, "ceil")) {
	sdsfreesplitres(argv, argc);	sdsfreesplitres(argv, argc);		if (count_s0() > 0) {
}}			push_s0(ceil(pop_s0()));
		}
static void completion(const char *input, linenoiseCompletions *lc) {}static void completion(const char *input, linenoiseCompletions *lc) {}	} else if (!strcasecmp(word, "floor")) {
		if (count_s0() > 0) {
static char *hints(const char *input, int *color, int *bold) {static char *hints(const char *input, int *color, int *bold) {			push_s0(floor(pop_s0()));
	int i;	int i;		}
	} else if (!strcasecmp(word, "round")) {
	clear(s0);	clear(s0);		if (count_s0() > 0) {
	clear(s1);	clear(s1);			push_s0(round(pop_s0()));
		}
	eval(input);	eval(input);	} else if (!strcasecmp(word, "sin")) {
	sdsclear(result);	sdsclear(result);		if (count_s0() > 0) {
			push_s0(sin(pop_s0()));
	result = sdscat(result, " ");	result = sdscat(result, " ");		}
	} else if (!strcasecmp(word, "cos")) {
	for (i = 0; i < count(s0); i++) {	for (i = 0; i < count(s0); i++) {		if (count_s0() > 0) {
		result = sdscatprintf(result, " %g", s0->items[i]);		result = sdscatprintf(result, " %g", s0->items[i]);			push_s0(cos(pop_s0()));
	}	}		}
	} else if (!strcasecmp(word, "tan")) {
	if (!isempty(s1)) {	if (!isempty(s1)) {		if (count_s0() > 0) {
		result = sdscat(result, "  ");		result = sdscat(result, "  ");			push_s0(tan(pop_s0()));
		}
		for (i = s1->top-1; i > -1; i--) {		for (i = s1->top-1; i > -1; i--) {	} else if (!strcasecmp(word, "ln")) {
			result = sdscatprintf(result, " %g", s1->items[i]);			result = sdscatprintf(result, " %g", s1->items[i]);		if (count_s0() > 0) {
		}		}			push_s0(log(pop_s0()));
	}	}		}
	} else if (!strcasecmp(word, "log")) {
	*color = HINT_COLOR;	*color = HINT_COLOR;		if (count_s0() > 0) {
			push_s0(log10(pop_s0()));
	return result;	return result;		}
}}	} else if (!strcasecmp(word, "!")) {
		if (count_s0() > 0) {
static sds buildpath(const char *fmt, const char *dir) {static sds buildpath(const char *fmt, const char *dir) {			a = pop_s0();
	return sdscatfmt(sdsempty(), fmt, dir, WORDS_FILE);	return sdscatfmt(sdsempty(), fmt, dir, WORDS_FILE);
}}			push_s0(a * tgamma(a));
		}
static void config() {static void config() {	} else if (!strcasecmp(word, "dup")) {
	sds filename = NULL;	sds filename = NULL;		if (!isempty_s0()) {
			push_s0(peek_s0());
	if (getenv("CLAC_WORDS") != NULL) {	if (getenv("CLAC_WORDS") != NULL) {		}
		filename = sdsnew(getenv("CLAC_WORDS"));		filename = sdsnew(getenv("CLAC_WORDS"));	} else if (!strcasecmp(word, "roll")) {
	} else if (getenv("XDG_CONFIG_HOME") != NULL) {	} else if (getenv("XDG_CONFIG_HOME") != NULL) {		a = pop_s0();
		filename = buildpath("%s/%s", getenv("XDG_CONFIG_HOME"));		filename = buildpath("%s/%s", getenv("XDG_CONFIG_HOME"));		b = pop_s0();
	} else if (getenv("HOME") != NULL) {	} else if (getenv("HOME") != NULL) {
		filename = buildpath("%s/.config/%s", getenv("HOME"));		filename = buildpath("%s/.config/%s", getenv("HOME"));		roll(pc->s0, pc->s1, b, a);
	}	}	} else if (!strcasecmp(word, "swap")) {
		swap(pc->s0);
	if (filename) {	if (filename) {	} else if (!strcasecmp(word, "drop")) {
		load(filename);		load(filename);		pop_s0();
		sdsfree(filename);		sdsfree(filename);	} else if (!strcasecmp(word, "count")) {
	}	}		push_s0(count_s0());
}}	} else if (!strcasecmp(word, "clear")) {
		clear_s0();
int main(int argc, char **argv) {int main(int argc, char **argv) {	} else if (!strcasecmp(word, "stash")) {
	char *line;	char *line;		move(pc->s0, pc->s1, pop_s0());
	} else if (!strcasecmp(word, "fetch")) {
	result = sdsempty();	result = sdsempty();		move(pc->s1, pc->s0, pop_s0());
	} else if (!strcasecmp(word, ".")) {
	config();	config();		move(pc->s0, pc->s1, 1);
	} else if (!strcasecmp(word, ",")) {
	if (argc == 2) {	if (argc == 2) {		move(pc->s1, pc->s0, 1);
		eval(argv[1]);		eval(argv[1]);	} else if (!strcasecmp(word, ":")) {
		move(pc->s0, pc->s1, count_s0());
		while (count(s0) > 0) {		while (count(s0) > 0) {	} else if (!strcasecmp(word, ";")) {
			printf("%g\n", pop(s0));			printf("%g\n", pop(s0));		move(pc->s1, pc->s0, count_s1());
		}		} 	} else if ((n = get(pc, word)) != NULL) {
 		eval(pc, n->meaning);
		exit(0);		exit(0);	} else {
	}	}		a = strtod(word, &z);

	if (argc > 2) {	if (argc > 2) {		if (*z == '\0') {
		fprintf(stderr, "usage: clac [expression]\n");		fprintf(stderr, "usage: clac [expression]\n");			push_s0(a);
		exit(1);		exit(1);		} else if (!isalpha(word[0])) {
	}	}			push_s0(NAN);
		}
	linenoiseSetHintsCallback(hints);	linenoiseSetHintsCallback(hints);	}
	linenoiseSetCompletionCallback(completion);	linenoiseSetCompletionCallback(completion);}

	while((line = linenoise("> ")) != NULL) {	while((line = linenoise("> ")) != NULL) {static void eval(p_context pc, const char *input) {
		if (!strcmp(line, "words")) {		if (!strcmp(line, "words")) {	int i, argc;
			node *curr = head;			node *curr = head;
	sds *argv = sdssplitargs(input, &argc);
			while (curr != NULL) {			while (curr != NULL) {
				printf(WORDEF_FMT, curr->word, curr->meaning);				printf(WORDEF_FMT, curr->word, curr->meaning);	for (i = 0; i < argc; i++) {
				curr = curr->next;				curr = curr->next;		process(pc, argv[i]);
			}			}	}
		} else if (!strcmp(line, "reload")) {		} else if (!strcmp(line, "reload")) {
			cleanup();			cleanup();	sdsfreesplitres(argv, argc);
			config();			config();}
		} else if (!isempty(s0)) {		} else if (!isempty(s0)) {
			hole = peek(s0);			hole = peek(s0);static sds buildpath(const char *fmt, const char *dir) {
			clear(s0);			clear(s0);	return sdscatfmt(sdsempty(), fmt, dir, WORDS_FILE);
			printf(OUTPUT_FMT, hole);			printf(OUTPUT_FMT, hole);}
		}		}
static void config(p_context pc) {
		sdsclear(result);		sdsclear(result);}
		linenoiseHistoryAdd(line);		linenoiseHistoryAdd(line);
		free(line);		free(line);int main(int argc, char **argv) {
	}	}	char *line;
	hcamp_context hc;
	sdsfree(result);	sdsfree(result);	p_context pc = &hc;
	cleanup();	cleanup();
    setvbuf(stdout, NULL, _IONBF, 0);
	return 0;	return 0;    setvbuf(stderr, NULL, _IONBF, 0);
}}    setvbuf(stdin, NULL, _IONBF, 0);

	mc = pc;

	init_hcamp_context(pc);
	config(pc);

	if (argc == 2) {
		eval(pc, argv[1]);

		while (count_s0() > 0) {
			printf("%d\n", pop_s0());
		}

		exit(0);
	}

	if (argc > 2) {
		fprintf(stderr, "usage: clac [expression]\n");
		exit(1);
	}

	while((line = linenoise("> ")) != NULL) {
		if (!strcmp(line, "words")) {
			node *curr = pc->head;

			while (curr != NULL) {
				printf(WORDEF_FMT, curr->word, curr->meaning);
				curr = curr->next;
			}
		} else if (!strcmp(line, "reload")) {
			cleanup(pc);
			config(pc);
		} else if (!strcmp(line, "exit")) {
			break;
		} else {
			clear_s0();
			clear_s1();

			eval(pc, line);

			if (!isempty_s0()) {
				pc->hole = peek_s0();
				clear_s0();
				printf(OUTPUT_FMT, pc->hole);
			}
		}

		sdsclear(pc->result);
		free(line);
	}

	sdsfree(pc->result);
	cleanup(pc);

	return 0;
}